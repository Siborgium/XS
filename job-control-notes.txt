XS job control implementation notes

...
main.cxx:main():Global
struct termios xs_tmodes;
main.cxx:main():Initialization section
if (isinteractive()) {
while (!isforeground()) kill(-pid, SIGTTIN);
 ... signals, etc.
setpgid(pid, pid);
tcsetpgrp(0, pid);
tcgetattr(0, &xs_tmodes);
}
...
src/stdenv.hxx:
Remove #define setpgrp ...
...
src/xs.hxx:
extern struct termios xs_tmodes;
...
src/prim-sys.cxx:
Remove PRIM(newpgrp).
Remove setpgrp() call from PRIM(background).
PRIM(fgpgrp)
arg: pgid
if {!isinteractive()} throw error fg 'Not an interactive shell'
tcsetpgrp(0, pgid);
tcsetattr(0, TCSADRAIN, &p.tmodes);
kill(-pgid, SIGCONT);
ewaitfor(pgid);
tcsetpgrp(0, getpgrp());
tcgetattr(0, &p.tmodes);
tcsetattr(0, TCSADRAIN, &xs_tmodes);
PRIM(bgpgrp)
arg: pgid
if (!isinteractive()) throw error bg 'Not an interactive shell'
kill(-pgid, SIGCONT);
...
src/proc.cxx:
dowait() must pass WUNTRACED as option (arg 2) to wait3().
#include <sys/types.h>
#include <unistd.h>
extern bool isforeground(void) {
return tcgetpgrp(0) == getpgrp();
}
Add a tmodes field to struct Proc.
Add an accessor proc_tmodes(pid) for tmodes field.
efork() must do the following for a new process.
parent, where pid is nonzero:
if (isinteractive()) {
setpgid(pid, pid);
if (isforeground()) tcsetpgrp(0, pid);
}
child, where pid is zero:
if (isinteractive()) {
setpgid(0, 0);
if (isforeground()) tcsetpgrp(0, getpgrp());
}
...
src/signal.cxx:initsignals():
if interactive
 set [sigstop, sigtstp, sigttin, sigttou] to sig_ignore
...
src/initial.xs
fn fg {|pgid|
	if {!~ $pgid <=&apids} throw error fg 'not a job'
	$&fgpgrp $pgid
}
fn bg {|pgid|
	if {!~ $pgid <=&apids} throw error bg 'not a job'
	$&bgpgrp $pgid
}
Rework fn-jobs:
 ps -o pgid,ni,etime,time,stat,wchan,%cpu,%mem,command -p <={%flatten , <=$&apids}
Remove fn-newpgrp
...
man/xs.1:
Remove $&newpgrp from PRIMITIVE FUNCTIONS.
Add $&fgpgrp and $&bgpgrp to PRIMITIVE FUNCTIONS.
Add `fg <pgid>` and `bg <pgid>` to BUILTIN COMMANDS.
...
doc/TODO:
Job control is done.
...
>>> HERE >>>>>>>>>>>>>>>
...
The modification to src/signal.cxx:initsignals() is wrong:
 969 217422 rt_sigprocmask(SIG_BLOCK, [HUP INT QUIT ALRM TERM TSTP TTIN TTOU]>
 970 217422 rt_sigaction(SIGINT, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_f>
 971 217422 rt_sigaction(SIGTERM, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_>
 972 217422 rt_sigaction(SIGHUP, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_f>
 973 217422 rt_sigaction(SIGQUIT, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_>
 974 217422 rt_sigaction(SIGALRM, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_>
 975 217422 rt_sigaction(SIGTSTP, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_>
 976 217422 rt_sigaction(SIGTSTP, {sa_handler=SIG_IGN, sa_mask=[], sa_flags=S>
 977 217422 rt_sigaction(SIGTTOU, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_>
 978 217422 rt_sigaction(SIGTTOU, {sa_handler=SIG_IGN, sa_mask=[], sa_flags=S>
 979 217422 rt_sigaction(SIGTTIN, {sa_handler=0x7f0315b820e0, sa_mask=[], sa_>
 980 217422 rt_sigaction(SIGTTIN, {sa_handler=SIG_IGN, sa_mask=[], sa_flags=S>
 981 217422 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
 982 217422 rt_sigaction(SIGWINCH, {sa_handler=0x7f0315b75da0, sa_mask=[], sa>
Note how SIGTSTP, SIGTTOU and SIGTTIN are ignored immediately after setting
 their handlers.
...
To test that a backgrounded job blocks on input:
{ echo <=read } &
...
doc/TUTORIAL.md:
Describe `fg`, `bg` and `jobs` usage.
...
=> examples/ via `./examples.sh snapshot`:
~/.xslib.d/xs-builtins.xs:-xs-help: Add `bg` and `fg`.
~/.xsrc.d/xs.xs:xs-quickref:
  Add comment to "commands" section:
    ├ «cmd»& executes in a new background process, setting $apid. ┤
  Add `bg`, `fg` and `jobs` in a new "jobs" section below the above comment.
...
Follow-on:
See doc/TODO: Figure out how to report completed job w/o corrupting prompt.
Write a doc/JOB_CONTROL: Note how it's possible to create a tree of job-control
 shells and describe techniques to make sense of the output of `jobs` as a
 result of traversing the tree of shells.
